<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程（六）：final]]></title>
    <url>%2F2018%2F07%2F17%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Afinal%2F</url>
    <content type="text"><![CDATA[1、概念 final也是Java中的一个关键字，它可以修饰类、方法和属性，表示所修饰的内容一旦赋值之后就不会再被改变 。被final修饰的类不能被其他类继承，被修饰的方法不能被重写，被修饰的属性不能再赋值。这是我们比较熟悉的用法，但是我们不太熟悉的就是final在并发编程中也有很大的作用。 2、抑制重排序 final可以阻止某些重排序，具体规则有两条： 在构造方法内对一个final字段的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final字段对象的引用，与随后初次读这个final字段，这两个操作不能重排序。 来看下面一段代码： 123456789101112131415161718192021public class FinalExample &#123; int i; final int j; static FinalExample obj; public FinalExample() &#123; i = 1; j = 2; &#125; public static void write() &#123; obj = new FinalExample(); &#125; public static void read() &#123; FinalExample finalExample = FinalExample.obj; int a = finalExample.i; int b = finalExample.j; &#125;&#125; 我们假设线程A执行write()方法，另外一个线程B执行read()方法。 先看一下对final字段进行写操作时，不同线程执行write方法和read方法的一种可能情况是： 从上图中可以看出，普通的字段可能在构造方法完成之后才被真正的写入值，所以另一个线程在访问这个普通变量的时候可能读到了０，这显然是不符合我们的预期的。但是final字段的赋值不允许被重排序到构造方法完成之后，所以在把该字段所在对象的引用赋值出去之前，final字段肯定是被赋值过了，也就是说这两个操作不能被重排序。 再来看一下初次读取final字段的情况，下边是不同线程执行write()方法和read()方法的一种可能情况： 从上图可以看出，普通字段的读取操作可能被重排序到读取该字段所在对象引用前边，自然会得到NullPointerException异常喽，但是对于final字段，在读final字段之前，必须保证它前边的读操作都执行完成，也就是说必须先进行该字段所在对象的引用的读取，再读取该字段，也就是说这两个操作不能进行重排序。 总的来说就是在读一个对象的final字段之前一定会先读包含这个final字段的对象的引用。 如果final字段是引用类型的话，写final字段的重排序规则对编译器和处理器增加了一条规则，在构造方法内对一个final引用的对象的成员属性的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序。 1234567891011121314151617181920212223public class FinalReferenceExample &#123; final int[] intArray; static FinalReferenceExample obj; public FinalReferenceExample() &#123; intArray = new int[1]; //1 intArray[0] = 1; //2 &#125; public static void writerOne() &#123; //写线程A执行 obj = new FinalReferenceExample(); //3 &#125; public static void writerTwo() &#123; //写线程B执行 obj.intArray[0] = 2; //4 &#125; public static void reader() &#123; //读线程C执行 if (obj != null) &#123; //5 int temp1 = obj.intArray[0]; //6 &#125; &#125;&#125; 上段代码假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader()方法。 1是对final字段的写入，2是对这个final字段引用的对象的成员属性的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。 3、底层原理 现在我们以x86处理器为例，说明final语义在处理器中的具体实现。 写final字段的重排序规则会要求译编器在final字段的写之后，构造方法return之前，插入一个StoreStore障屏。读final字段的重排序规则要求编译器在读final字段的操作前面插入一个LoadLoad屏障。 由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final字段需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final字段需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障。 ４、总结 final关键字除了常用的修饰类、方法和属性的作用外，在并发编程中还可以抑制重排序。final抑制重排序的规则主要是这两条： 在构造方法内对一个final字段的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final字段对象的引用，与随后初次读这个final字段，这两个操作不能重排序。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（五）：volatile]]></title>
    <url>%2F2018%2F07%2F16%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Avolatile%2F</url>
    <content type="text"><![CDATA[1、概述 volatile可以看作是轻量级的synchronized，它只保证了共享变量的可见性，但是不保证原子性，另外还能禁止虚拟机的重排序，在一定程度上保证有序性。如果恰当使用volatile关键字，在性能上比使用synchronized关键字要好。 2、volatile的作用保证可见性123456789101112131415161718192021222324252627public class Volatile implements Runnable&#123; private static volatile boolean flag = true ; @Override public void run() &#123; while (flag)&#123; System.out.println(Thread.currentThread().getName() + "正在运行。。。"); &#125; System.out.println(Thread.currentThread().getName() +"执行完毕"); &#125; public static void main(String[] args) throws InterruptedException &#123; Volatile aVolatile = new Volatile(); new Thread(aVolatile,"thread A").start(); System.out.println("main 线程正在运行") ; TimeUnit.MILLISECONDS.sleep(100) ; aVolatile.stopThread(); &#125; private void stopThread()&#123; flag = false ; &#125;&#125; 上段代码使用了volatile保证了main线程修改了变量后，其他线程能立即获取到最新的值，如果没有用volatile修饰的话，那么代码停止的时间可能会有所延迟。 使用volatile关键字会强制将修改的值立即写入主存，此时其他线程由于缓存一致性协议会导致缓存无效，重新去主内存中读取最新的值。 不保证原子性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class VolatileDemo &#123; private volatile int count = 0; public void inc() &#123; count++; &#125; public void dec() &#123; count--; &#125; public int get() &#123; return count; &#125; public static void main(String[] args) &#123; while (true) &#123; final VolatileDemo demo = new VolatileDemo(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; demo.inc(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; demo.dec(); &#125; &#125; &#125;); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("count=" + demo.get()); &#125; &#125;&#125;结果：count=0count=0count=0count=1count=0 上段代码的运行结果大多数情况下为0，但是有些时候也会出现其他结果，这是因为count++和count--并不是一个原子性操作。volatile只能保证每次读取的是最新的值，但是没办法保证操作的原子性。 保证有序性 volatile能够禁止虚拟机的重排序，可以保证一定的有序性 。 volatile修饰的变量的有序性有两层含义： （1）所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。 （2）禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。 1234567//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 3、底层原理 其实前面文章学习Java内存模型时了解到的高速缓存和缓存一致性协议与volatile的底层原理密切相关，可以去回顾一下。 在对volatile修饰的共享变量进行写操作的时候，JVM会向处理器发送一条Lock前缀的指令，这个指令会将当前处理器缓存行的数据会写回到系统内存，这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效，由于缓存一致性协议，每个处理器会通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 ４、经典案例12345678910111213141516public class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 双重检查锁定的单例模式中为什么要使用volatile关键字呢？主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（四）：synchronized]]></title>
    <url>%2F2018%2F07%2F15%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Asynchronized%2F</url>
    <content type="text"><![CDATA[1、概念 synchronized 是 Java 中的关键字，它利用锁机制确保在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。synchronized 具有原子性、可见性和有序性。 2、使用方式 修饰代码块： 123synchronized (this) &#123; //括号中可以是任意对象 ...&#125; 修饰方法： 12345678// 修饰普通方法public synchronized void xxx() &#123; ...&#125;//修饰静态方法public static synchronized void xxx() &#123; ...&#125; 修饰普通方法时，锁对象为当前实例对象；修饰静态方法时锁对象为当前类的Class对象。 3、作用原子性 原子性是指一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行该操作，也就是说这些操作是不可分割的，线程不能在这些操作上交替执行。 synchronized 通过加锁的方式将一些代码包裹起来，这些代码成为受保护的代码，在同一时刻只有持有锁的线程才能进入受保护的区域，确保了操作的原子性。 可见性 可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。当一个线程获取锁时，会把该线程对应的工作内存置为无效，从而使被锁保护的代码块必须从主内存中获取共享变量，当一个线程释放锁时，会把该线程对应的工作内存中的共享变量刷新到主内存。 有序性 synchronized只能保证在执行同步代码块时，它之前的代码已经执行完成，在同步代码块执行完成之前，代码块后边的代码是不能执行的，也就是只保证加锁前、加锁中、加锁后这三部分的执行时序，但是同步代码块之前的代码可以重排序，同步代码块中的代码可以重排序，同步代码块之后的代码也可以进行重排序 。 4、底层原理 现在我们来看看synchronized 关键字的底层原理。先看一段代码： 123456789101112131415public class Main &#123; public synchronized void test1() &#123; &#125; public synchronized void test2() &#123; &#125; public void test3() &#123; synchronized (this) &#123; &#125; &#125;&#125; 利用javap -v命令查看字节码文件（只看关键部分）： 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized void test1(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED //看这 Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 this Lcom/hengtian/main/Main; public synchronized void test2(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED //看这 Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 this Lcom/hengtian/main/Main; public void test3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter //看这 4: aload_1 5: monitorexit //看这 6: goto 14 9: astore_2 10: aload_1 11: monitorexit //看这 12: aload_2 13: athrow 14: return 从字节码文件中可以看出同步方法是使用了ACC_SYNCHRONIZED指令，同步代码块使用了monitorenter和monitorexit指令。 JVM会通过ACC_SYNCHRONIZED指令判断当前方法是不是同步方法，如果是同步方法则会检查当前线程是否持有monitor(锁)，只有持有monitor(锁)的线程才能进入同步方法中。 执行同步代码块则先执行monitorenter指令，检查当前线程是否持有monitor(锁)，只有持有monitor(锁)的线程才能进入同步代码块中，执行完代码后退出时或者遇到异常时执行monitorexit指令释放monitor(锁)。 由此可见，synchronized 底层使用的是monitor，通过判断线程是否持有monitor来确保同一时刻只有一个线程执行代码。 5、重入锁 重入锁是指线程在获取到锁之后能够再次获取该锁而不会被阻塞，synchronized是一个重入锁。具体见代码： 123456789101112public class Main &#123; public static void main(String[] args) &#123; synchronized (Main.class) &#123; System.out.println("执行同步代码块..."); m(); &#125; &#125; public synchronized static void m() &#123; System.out.println("执行m()..."); &#125;&#125; Main线程在获取到锁后执行了同步代码块中的输出语句后执行静态同步方法，由于已经获得锁了，此时进入静态同步方法不需要再获取一把锁可以直接进入，这就是锁的可重入。 6、优化 在以前synchronized被人称为重量级锁，因为synchronized加锁释放锁是十分消耗资源的。在JDK1.6后Java开发团队对synchronized进行了优化，引入偏向锁和轻量级锁，减少了加锁释放锁的性能消耗。 在JDK1.6后，锁的状态一共有4种，级别从高到低分别为：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级，锁升级后是不能降级的。 偏向锁 大多数情况下，锁不仅不存在多线程竞争，而且还总是由同一线程多次获得。为了让线程获取锁的代价更低引入了偏向锁的概念。偏向锁就是当一个线程访问同步块并获取锁时，JVM会记录下该线程的ID，如果没有其他线程竞争，则该线程进入和退出同步块时不需要再进行加锁和解锁的操作。如果有其他线程与其竞争则将锁撤销后再升级为轻量级锁。 轻量级锁 大多数情况下线程持有锁的时间都不会太长，如果直接挂起线程，性能消耗比较大，因此JVM会让想要获取锁的线程空循环几次，这叫做自旋，假设在自旋几次后该线程获取到了锁，则可以正常执行代码，如果超过了一定次数后还不能获取锁，则会浪费CPU资源，此时轻量级锁就会膨胀成重量级锁，也就是线程将会被挂起形成阻塞。 各种锁的比较 锁 优点 缺点 应用场景 偏向锁 加锁和解锁不需要额外的消耗 线程间存在锁竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块场景 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度 如果始终得不到锁竞争的线程，使用自旋会消耗CPU 追求响应时间，同步块执行速度非常快 重量级锁 线程竞争不使用自旋，不会消耗CPU 线程阻塞，响应速度缓慢 追求吞吐量，同步执行速度较长 7、总结 synchronized可以确保原子性、可见性和有序性。 synchronized可以修饰代码块和方法，修饰代码块则锁为括号中指定的锁，修饰普通方法时锁是当前实例，修饰静态方法时锁是当前类的Class对象 synchronized 底层会检查当前线程是否持有monitor，只有持有monitor的线程才能进入代码块或者方法 synchronized 具有可重入性 JVM会根据锁竞争的情况将锁的级别逐步升级]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（三）：Java内存模型]]></title>
    <url>%2F2018%2F07%2F10%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1、概述 在前面的文章中我们有提到线程安全性问题，在平时工作中如果稍不注意就会出现此类问题。想要解决线程安全性问题最重要的就是理解Java内存模型，重点了解主内存和工作内存的关系以及重排序相关知识点。 2、高速缓存 为了理解Java内存模型，首先我们得先了解一下计算机底层硬件的一些知识。随着CPU技术的发展，CPU的运行速度越来越快，但是内存技术的发展并没有跟上CPU技术发展的脚步，内存的速度跟不上CPU的速度，导致CPU在执行程序的时候总是要等待内存传输数据，这就浪费了好多时间。这样下去可不行啊，总不能让内存成为计算机技术的瓶颈啊，于是人们想出了一个好办法，在CPU和内存之间加了个高速缓存，这个缓存内存特别小但是速度特别快。有了高速缓存后，CPU就只跟高速缓存打交道了，缓存会预先从主内存中读取一些数据，当CPU需要数据的时候就会从缓存中读取数据。当CPU要写数据的时候也是先写到缓存中，然后缓存会在某个时候在写到主内存中。所以这个高速缓存提高了CPU利用了，大大节省了CPU等待内存读写的时间。 这样的机制在单处理器上没啥问题，但是在多处理器上就麻烦了，每个处理器都有自己的高速缓存，不同处理器之间的高速缓存是不共享的，如果一个变量在不同处理器上有多个副本，那么在一个处理器上对其进行修改的话，那么其余处理器上缓存的值就不一致了，这就是缓存一致性问题。 为了解决这个问题，人们又制定了一个规则就是缓存一致性协议。这个规则有多种，比如说当一个处理器往高速缓存写数据的时候会立即刷新到主内存，在这个过程中别的处理器是不可以访问这个变量的，或者不立即刷新到主内存，只是向其他处理器发一条广播信息说我这某个变量的值改变了，你们的缓存也应该变一变了。 3、重排序 上面说到了缓存一致性问题，还有一种硬件问题也比较重要。那就是计算机中为了使CPU内部的运算单元能够充分利用，CPU可能会将我们写的代码乱序执行，这样可以提高CPU的执行效率。比如下面这段代码： 12345678910111213141516171819202122public class Reordering &#123; private static boolean flag; private static int num; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!flag) &#123; Thread.yield(); &#125; System.out.println(num); &#125; &#125;, "t1"); t1.start(); num = 5; flag = true; &#125;&#125; 对于这段代码你肯定会说结果等于5，那可不一定，有时候在多线程环境下也有可能为0，也就是说flag=true有可能先于num=5执行。那么什么情况下会进行重排序呢？这里涉及到数据依赖性这个概念，如下代码： 1234567891011int a = 1;int b = 2; // a与b之间没有依赖关系，它们之间的顺序可以重排序---------------------------------------------------------int a = 1;int b = a; // 写一个变量后再读这个变量，存在依赖关系，不能重排序---------------------------------------------------------int a = 1;a = 2; // 写一个变量后再写这个变量，存在依赖关系，不能重排序---------------------------------------------------------int a = b;b = 1; // 读一个变量后再写这个变量，存在依赖关系，不能重排序 数据依赖性具体的定义为如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。编译器和处理器在重排序时不会改变存在数据依赖关系的两个操作的执行顺序。 既然存在重排序，那么为什么我们以前在写单线程的代码时没有感觉到呢？这是因为有一个as-if-serial语义，这个语义的意思就是不管怎么重排序，单线程程序的执行结果不能被改变。也就是说这个语义保证了在单线程中执行代码，最终结果是和代码顺序执行的结果一致的。但是多线程就没那么好运了，重排序会经常困扰着我们，还好Java内存模型的提出为我们解决此类问题提供了规范。下面开始介绍Java内存模型。 4、Java内存模型 上面介绍的硬件问题对于Java内存模型有什么关系呢？我们知道Java并发编程中有三个主要问题分别为原子性问题、可见性问题、有序性问题。缓存一致性问题会导致并发编程中的可见性问题，重排序会导致有序性问题。Java内存模型就是为了解决并发编程中存在的这些问题。 Java内存模型（Java Memory Model ,JMM）是JVM中的一种规范，屏蔽了各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能保证效果一致。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。线程、主内存和工作内存三者之间的关系如图所示： 这里的主内存和工作内存可以简单类比成我们上面介绍高速缓存时提到的计算机主内存和高速缓存。 那么Java内存模型到底如何帮助我们解决并发编程存在的问题呢？其实非常简单，它提供了3个同步原语synchronized、volatile和final，这三个同步原语封装了底层实现，我们只要直接使用就可以了。我们下篇文章就会介绍这三个同步原语的使用以及原理。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（二）：入门基础]]></title>
    <url>%2F2018%2F07%2F09%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1、进程与线程 提到多线程那么我们就要先要认识一下进程，所谓进程就是我们操作系统中正在运行的一个程序，打开Windows操作系统的任务管理器你就能很清楚的看到一个个进程了。而线程则是一个进程中可以执行多个任务，每一个任务可以称之为线程。 那么为什么要使用线程呢？那是因为进程的创建、撤销和切换都需要大量的时间和空间的开销，用进程实现多任务处理是非常耗费CPU资源的，因此为了提高系统的效率计算机前辈们引入了线程概念，即在一个进程中用多个线程来实现多任务的处理，创建多个线程比创建多个进程大大减少了系统的开销。 2、并行与并发 在平时工作之中我们也经常听到并行与并发，那么这两个又有什么区别呢？ 并发指应用能够交替执行不同的任务，比如吃饭吃到一半，电话来了，你停下来接了电话，接完后继续吃饭。 并行指应用能够同时执行不同的任务 ，比如吃饭吃到一半，电话来了，你一边吃饭一边接电话。 3、线程状态 Java中的线程状态分为6种： 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的成为“运行”。 新创建的线程一旦调用start()，将会等待获取CPU的执行权，此时处于就绪状态（ready），如果获取到了CPU的执行权就会变为运行中（running）状态。 阻塞(BLOCKED)：线程没有获取到对象锁则会进入阻塞（blocked）状态。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIME_WAITING)：该状态不同于WAITING，它可以在指定的时间内自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 4、实现多线程继承Thread类 创建一个类继承Thread类并且重写run方法即可 1234567891011121314151617public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); &#125; &#125; public static void main(String[] args) &#123; MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); t1.start(); t2.start(); &#125;&#125; 实现Runnable接口 创建一个类实现Runnable接口并且重写run方法即可 12345678910111213141516171819public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); &#125; &#125; public static void main(String[] args) &#123; MyRunnable target = new MyRunnable(); Thread t1 = new Thread(target); Thread t2 = new Thread(target); t1.start(); t2.start(); &#125;&#125; 实现Callable接口 创建一个类实现Callable接口并且重写call方法即可，该方式可以获得返回值和抛出异常。 12345678910111213141516171819202122232425262728public class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 0; i &lt; 100; i++) &#123; sum += i; &#125; return sum; &#125; public static void main(String[] args) &#123; MyCallable callable = new MyCallable(); FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(callable); new Thread(result).start(); try &#123; Integer sum = result.get(); System.out.println(sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用细节 run方法仅仅是封装被执行的代码，直接调用run方法就是普通方法，要启动线程就得使用start方法。 我们在平时使用中一般都是用实现Runnable接口的方式，这样可以避免Java单继承的限制，而且还可以将运行任务与运行机制解耦合。如果需要返回值和抛出异常则可以使用实现Callable的方式。 6、线程相关方法获取线程ID long getId() ：通过该方法可以获取线程的ID 1234567891011public class Main &#123; public static void main(String[] args) &#123; System.out.println(new Thread().getId()); System.out.println(new Thread().getId()); System.out.println(new Thread().getId()); &#125;&#125;结果：111213 获取和设置线程名称 void setName(String name) ：设置线程名称 String getName()：获取线程的名称 public Thread(String name)：构造方法设置线程名称 123456789public class Main &#123; public static void main(String[] args) &#123; Thread t1 = new Thread("T1"); Thread t2 = new Thread(); t2.setName("T2"); System.out.println(t1.getName()); System.out.println(t2.getName()); &#125;&#125; 获取和设置线程优先级 void setPriority(int newPriority)：设置线程优先级 Java线程优先级的范围为1~10，默认的优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。但是在不同的JVM和操作系统上，线程的优先级会有差异甚至会忽略优先级的设定，所以程序的正确性不能依赖于线程的优先级高低。 1234567891011public class Main &#123; public static void main(String[] args) &#123; Thread t1 = new Thread("T1"); System.out.println("t1的优先级为" + t1.getPriority()); t1.setPriority(Thread.MAX_PRIORITY); System.out.println("t1的优先级为" + t1.getPriority()); &#125;&#125;结果：t1的优先级为5t1的优先级为10 获取当前正在执行的线程 static Thread currentThread()：获取当前正在执行的线程对象的引用 1234567public class Main &#123; public static void main(String[] args) &#123; System.out.println("当前线程为：" + Thread.currentThread().getName()); &#125;&#125;结果：当前线程为：main sleep方法 线程调用sleep方法会让线程休眠一段时间再执行，线程进入超时等待状态（TIME_WAITING）。 static void sleep(long millis) throws InterruptedException：指定毫秒内休眠 static void sleep(long millis, int nanos) throws InterruptedException：指定毫秒加纳秒内休眠 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; System.out.println(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(2); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(3); &#125;&#125; 上段代码main线程每隔一秒休眠一次，然后输出一个数字 守护线程 boolean isDaemon()：判断该线程是否为守护线程 void setDaemon(boolean on)：将该线程标记为守护线程或者普通线程 线程分为普通线程和守护线程，如果所有普通线程都死掉的情况下，守护线程就会退出。守护线程主要是为普通线程提供便利服务的，比如Java中的垃圾回收器就是一个守护线程。 守护线程只有在线程未启动的时候才能设置，否则的话会抛出异常。 1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; public static void main(String[] args) &#123; MyDaemon d1 = new MyDaemon(); MyDaemon d2 = new MyDaemon(); d1.setName("关羽"); d1.setDaemon(true); d2.setName("张飞"); d2.setDaemon(true); d1.start(); d2.start(); Thread.currentThread().setName("刘备"); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;&#125;class MyDaemon extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + ":" + i); &#125; &#125;&#125;结果：刘备:98刘备:99张飞:62张飞:63张飞:64张飞:65关羽:69关羽:70关羽:71 上段代码main线程刘备执行结束后，很快关羽线程和张飞线程没完成任务也都结束了。 yield方法 static void yield()：表示放弃此次时间片时间，等待下次执行 线程的执行需要获取CPU的时间片，如果一个线程已经获得了时间片，但是不想执行，可以放弃此次时间片让其他线程去获取。但是这个方法只是建议CPU不要在此次时间片内执行该线程，但是最后实际情况还得看CPU如何决定。 join方法 void join()：等待该线程终止才能继续执行 void join(long millis)：在指定毫秒数内等待该线程终止，如果超出指定时间就继续执行 void join(long millis, int nanos)：同上，只不过加上了纳秒 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("T1执行完了"); &#125; &#125;, "T1"); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; &#125;&#125; interrupt方法 void interrupt()：设置线程的中断状态为true boolean isInterrupted：返回该线程的中断状态，并不修改中断状态 static boolean interrupted()：返回该线程的中断状态，如果中断状态为true的话，会将中断状态设置为false 线程中断的方法有stop和interrupt方法。 stop方法可以立刻终止线程释放锁，这种暴力的方法会导致对象状态不一致、资源没有被释放等安全问题，所以被设置为过时了。现在我们主要使用的是interrupt方法。 interrupt不会真正地去停止一个线程，只不过是给线程发了一个信号，具体是停止操作还是继续运行需要线程自己去进行。 线程调用sleep()、wait()、join()等方法而进入阻塞状态的，此时调用interrupt()会产生InterruptedException 异常终止线程并且清除中断状态。 1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; Runnable target = new BlockedTask(); Thread t = new Thread(target); t.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.interrupt(); &#125;&#125;class BlockedTask implements Runnable &#123; @Override public void run() &#123; System.out.println("开始执行任务"); try &#123; while (true) &#123; Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("有其他线程中断了此线程"); System.out.println("中断状态:"+Thread.currentThread().isInterrupted()); &#125; finally &#123; System.out.println("任务执行完成"); &#125; &#125;&#125;结果：开始执行任务有其他线程中断了此线程中断状态:false任务执行完成 7、总结 一个操作系统中可以有多个进程，一个进程中可以有多个线程。 并发指应用能够交替执行不同的任务，并行指应用能够同时执行不同的任务。 实现多线程有三种方式，分别为继承Thread类、实现Runnable接口和实现Callable接口。 Java中线程有6种状态分别为初始、运行、阻塞、等待、超时等待和终止。 线程相关方法的使用。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（一）：并发编程的挑战]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[1、前言 这段时间以来为了回顾多线程的知识点，重新翻阅了《Java核心技术：卷一》、《Java并发编程的艺术》、《Java并发编程实战》以及一些博客，在学习的过程中对于Java多线程有了更深入的理解，所以想要把这些知识点归纳总结起来，一方面加深自己学习的印象，另一方面方便日后复习。好了话不多少，下面开始正题吧~ 2、为什么要使用并发 一直以来计算机硬件发展极其迅速，计算机从单核CPU发展到了多核CPU，计算能力也大幅提升，为了充分利用多核CPU的计算能力，并发编程的趋势开始流行起来。并发编程的目的就是为了让程序运行的更快，充分“压榨”计算机的计算能力。然而事物具有两面性，并发编程也面临着非常多的挑战，比如上下文切换问题、死锁问题等等。 3、并发编程的挑战安全性问题 由于多个线程的操作执行顺序是不可预测的，如果多个线程访问同一个共享变量，并且对这个变量进行非原子性操作就会产生安全性问题。 12345678910111213141516171819202122232425262728293031public class MyRunnable implements Runnable &#123; private int count = 0; public int getNext() &#123; return count++; &#125; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + ":" + getNext()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; MyRunnable target = new MyRunnable(); Thread t1 = new Thread(target); Thread t2 = new Thread(target); t1.start(); t2.start(); &#125;&#125;结果：Thread-1:0Thread-0:1Thread-0:2Thread-1:2Thread-1:3出现了两个2 解决安全性问题可以使用同步机制，这个之后的文章会介绍。 活跃性问题 活跃性问题包括死锁、饥饿、活锁，最常见的就是死锁。死锁就是两个线程互相争夺资源发生的相互等待的现象。饥饿就是一个线程一直占着CPU资源导致其他线程得不到CPU资源。活锁指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。 以下是死锁例子： 123456789101112131415161718192021222324252627282930313233343536373839404142public class DeadLockDemo &#123; private static String A = "A"; private static String B = "B"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (A) &#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (B) &#123; System.out.println("1"); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (B) &#123; synchronized (A) &#123; System.out.println("2"); &#125; &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125;结果：程序卡着不动，没有输出 性能问题 性能问题包括多方面，其中上下文切换问题比较突出。我们知道时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们觉得多个线程是同时执行的。CPU每次进行切换时会保存上一个任务的状态，以便下次切换能够恢复到原来的状态，但是这个切换是非常耗性能的，这个就是上下文切换问题。举个例子，比如我们读一本英文书，发现某个单词不认识，于是我们要先记住读到了哪一页，然后去查这个单词的意思，最后再回来读，如果频繁进行这样的操作显然是影响效率的。 减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和协程，这个我们先提一提，以后在展开。 4、总结 使用并发的原因就是为了尽可能的“压榨”计算机的计算能力，从而让程序执行的更快，但是不正确的使用并发编程也会带来很多棘手的问题，比如安全性问题、活跃性问题和性能问题，这些问题需要我们在使用并发编程时需要注意的。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码分析]]></title>
    <url>%2F2018%2F07%2F01%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、前言 我们之前分析了ArrayList的源码，今天我们再来分析一下LinkedList。这两兄弟都是List接口下的实现，ArrayList基于数组实现，查找和修改效率高，增加和删除效率低，而相反的LinkedList是基于链表实现的，增加和删除效率高，查找和修改效率低。好了废话不多说，开始分析源码吧。 2、成员属性123456789101112131415161718192021222324// 集合大小transient int size = 0;// 头结点引用transient Node&lt;E&gt; first;// 尾结点引用transient Node&lt;E&gt; last;// 结点内部类private static class Node&lt;E&gt; &#123; // 元素 E item; // 后置结点 Node&lt;E&gt; next; // 前置结点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList是基于双向链表实现的，它的数据结构如下图所示： F表示头结点引用，L表示尾结点引用，链表的每个结点都有三个元素，分别是前继结点引用(P)，结点元素的值(E)，后继结点的引用(N)。 以上代码中的内部类Node就表示了这种数据结构。 3、构造方法123456789// 无参构造方法public LinkedList() &#123;&#125;// 传入外部集合的构造方法public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 构造方法就两个，十分简单，与ArrayList相比没有指定初始大小的构造方法。 4、核心方法 增： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 增加public boolean add(E e) &#123; // 在链表尾部添加一个元素 linkLast(e); return true;&#125;// 在指定位置插入public void add(int index, E element) &#123; // 检查下标是否越界 checkPositionIndex(index); if (index == size) // 在尾结点后插入 linkLast(element); else //在中间插入 linkBefore(element, node(index));&#125;// 添加传入集合的所有元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;// 指定位置插入传入集合的所有元素public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查下标是否越界 checkPositionIndex(index); // 将传入的集合转化为Object[] Object[] a = c.toArray(); int numNew = a.length; // 如果新增元素为0，则不添加 if (numNew == 0) return false; // 定义index结点的前置结点和后置结点 Node&lt;E&gt; pred, succ; // 如果index是在链表尾部 if (index == size) &#123; // 后置结点为null succ = null; // 前置结点为尾结点 pred = last; &#125; else &#123; // 后置结点为index结点 succ = node(index); // 前置结点为index结点的前置结点 pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; // 创建一个新结点链接到前置结点后 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); // 如果前置结点为空说明是头结点 if (pred == null) // 设置头结点为新结点 first = newNode; else //前置结点的后置结点位置为新结点 pred.next = newNode; // 前置结点更新为新结点，为下一次添加结点做准备 pred = newNode; &#125; // 循环结束后，如果后置结点为null则说明是在链表尾部插入的 if (succ == null) &#123; // 此时设置尾结点 last = pred; &#125; else &#123; // 否则的话更新前置结点的后置结点 pred.next = succ; // 更新后置结点的前置结点 succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125;// 在链表尾部添加元素void linkLast(E e) &#123; // 记录原尾部结点 final Node&lt;E&gt; l = last; // 在原尾部结点后链接一个新的结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 更新尾部结点为新创建的结点 last = newNode; if (l == null) // l为null说明是第一次加入数据，将头结点设置为新创建的结点 first = newNode; else // 更新原尾部结点的后置结点为新创建的结点 l.next = newNode; size++; modCount++;&#125;// 在指定结点前插入一个元素void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 记录指定结点的前置结点 final Node&lt;E&gt; pred = succ.prev; // 创建一个新结点其前置结点为记录的结点(pred)，后置结点为指定结点(succ) final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 这时新结点是指定结点的前置结点 succ.prev = newNode; // 如果指定结点的前置结点为null，说明指定结点是头结点 if (pred == null) // 此时头结点变为新结点 first = newNode; else // 指定结点的前置结点的后置结点要更新为新结点 pred.next = newNode; size++; modCount++;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F07%2F01%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、前言 在分析ArrayList源码之前，我们先来回顾一下数组。数组是最基本的数据结构之一，由于它可以直接操作内存，所以效率很高，但是数组有一个致命的缺点就是在数组初始化的时候就要指定数组的大小，并且后续操作不能更改数组的大小。在实际情况中，我们往往不清楚要存放多少个元素，我们更希望的是有一个容器可以在我们存放元素的时候能够自动扩容，因此ArrayList就诞生了。 ArrayList能够自动扩展大小以适应存储元素的不断增加，它的底层数据结构使用的是数组，因此也具备了数组的一些特点，比如查找修改快而插入删除慢。那么在了解数组和ArrayList的关系后，接下来就开始对ArrayList源码的分析吧。 注：本文使用JDK1.8 2、成员属性1234567891011121314151617// 默认初始化容量private static final int DEFAULT_CAPACITY = 10;// 空对象数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 空对象数组，用于区分EMPTY_ELEMENTDATA以知道第一个元素被添加进来的时候如何扩展private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 存放元素的数组 transient Object[] elementData; // non-private to simplify nested class access// 集合元素个数private int size;// 集合最大容量private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 3、构造方法1234567891011121314151617181920212223242526272829303132// 指定初始容量的构造方法public ArrayList(int initialCapacity) &#123; // 创建一个指定容量的Object数组赋给elementData if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;// 无参构造方法public ArrayList() &#123; // 将空对象数组赋给elementData this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// 传入外部集合的构造方法public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将集合转化为数组 elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // 如果该数组不是Object类型的则将其转化为Object类型数组 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 集合长度为0则设置空对象数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 当我们创建一个带有指定容量的ArrayList时会创建指定大小的Object数组，如果传入的是一个外部集合，那么会将该集合转化为数组并判断是否是Object类型数组，如果创建一个无参的ArrayList时，会设置成员属性中定义好的空对象数组。那么以前很多文章说创建ArrayList的时的初始化容量为10，但是构造方法里并没有体现出来啊，其实这个说法在1.6是对的，但是1.7以后就不是这样了，如果只能new ArrayList()的话，它的容量为0，当第一次add(E e)时才扩充为10，具体请看下面核心方法的分析。 4、核心方法 增： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 增加public boolean add(E e) &#123; // 增加前先判断是否要进行扩容 ensureCapacityInternal(size + 1); // 将元素增加到数组末尾，操作快速 elementData[size++] = e; return true;&#125;// 插入public void add(int index, E element) &#123; // 检查插入位置是否合法 rangeCheckForAdd(index); // 判断是否需要扩容 ensureCapacityInternal(size + 1); // 挪动插入位置后面的元素，操作较慢 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 插入位置赋上新值 elementData[index] = element; // 集合长度+1 size++;&#125;// 添加外部集合中的所有元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 转化为Object数组 Object[] a = c.toArray(); int numNew = a.length; // 判断是否需要扩容 ensureCapacityInternal(size + numNew); // 拷贝Object数组中的元素到elementData中 System.arraycopy(a, 0, elementData, size, numNew); // 新的集合长度 size += numNew; return numNew != 0;&#125;/* 扩容相关方法 */private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 判断是否是空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 与默认容量比较取最大值 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果最小容量大于数组长度就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // 数组原来的容量 int oldCapacity = elementData.length; // 新数组容量为原数组容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新数组容量还是小于最小容量那新数组容量就等于最小容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新数组容量大于集合最大容量则执行hugeCapacity方法 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 拷贝原来的元素到新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 每次添加元素前都会调用ensureCapacityInternal()检查集合容量，在这个方法内部会先调用calculateCapacity()计算添加元素所需的最小容量，如果集合内部的数组还是成员属性中的空对象数组，则返回默认容量与最小容量相比的最大值。一般我们第一次调用add(E e)返回的是默认容量，但是如果调用的是addAll(Collection&lt;? extends E&gt; c)且传入的集合的长度大于默认容量，则返回的是添加元素所需的最小容量了。接着将计算得出的最小容量传入ensureExplicitCapacity()判断如果最小容量大于集合内部的数组长度就需要扩容了。具体扩容的方法为grow()，每次扩容都是增加原来数组的一半，扩容实际上新建一个容量更大的数组，然后把原来数组中的元素复制到新的数组上。 删： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 删除指定位置的元素public E remove(int index) &#123; // 范围检查 rangeCheck(index); modCount++; // 旧值 E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // 将指定位置后面的元素向前挪动一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 置空，好让垃圾回收器工作 elementData[--size] = null; // 返回旧值 return oldValue;&#125;// 删除指定元素public boolean remove(Object o) &#123; // 如果这个元素为null if (o == null) &#123; // 遍历查找出第一个为null的元素将其删除 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 遍历查找出第一个与指定元素相同的元素将其删除 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null;&#125; 删除指定位置或者指定元素都会将删除位置后面的元素向前挪动，会涉及到数组的拷贝，效率比较慢。 改： 1234567891011// 指定位置更改public E set(int index, E element) &#123; // 范围检查 rangeCheck(index); // 旧值 E oldValue = elementData(index); // 替换新值 elementData[index] = element; // 返回旧值 return oldValue;&#125; 查： 1234567// 查找public E get(int index) &#123; // 范围检查 rangeCheck(index); // 返回指定位置的元素 return elementData(index);&#125; 5、总结 ArrayList底层是基于数组实现的，因此它对指定下标的查找和修改效率较好，但是删除和插入需要拷贝数组，效率较慢。 构造ArrayList时尽量指定容量，减少扩容时带来的数组拷贝操作。 每次添加元素之前会检查是否需要扩容，每次扩容都是增加原有容量的一半 。 每次对下标的操作都会进行安全性检查，如果出现数组越界就立即抛出异常。 ArrayList的所有方法都没有进行同步，因此它不是线程安全的。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL高级（五）：数据库锁机制]]></title>
    <url>%2F2018%2F06%2F27%2FMySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、概述 锁是计算机协调多个进程或纯线程并发访问某一资源的机制。 在数据库中，数据是可以供多个用户共享的，在并发环境下，为了保证数据的一致性和有效性必须要使用锁机制。举个生活中的例子，我们在电商网站上购物时，如果库存只有一个了，但是这个时候还有其他人要买，为了保证只有一个人购买到这件商品，这时我们就得使用数据库锁了。 2、锁的分类 从数据操作的类型分： 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。 从对数据操作的颗粒度分： 表锁 行锁 3、锁3.1、表锁 特点：偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定的粒度大，但是发生锁冲突的概率高，并发量低。 建表并插入一些数据： 12345678910create table mylock( id int not null primary key auto_increment, name varchar(20)) engine myisam;insert into mylock(name) values('a');insert into mylock(name) values('b');insert into mylock(name) values('c');insert into mylock(name) values('d');insert into mylock(name) values('e'); 读锁： Session1 Session2 获得表mylock的read锁 连接终端 当前session可以查询该表记录 其他session也可以查询该表的记录 当前session不能查询其他表 其他session可以增删改查其他表 当前session插入或者更新锁定的表都会报错 其他session插入或者更新锁定的表会一直等待获得锁 释放锁 session2获得了锁，插入操作完成 写锁： Session1 Session2 获得表mylock的write锁 连接终端 当前session不能查询其他表 当前session可以查询其他表 当前session对锁定的表的增删改查操作都可以执行 当前session对锁定的表进行操作会阻塞 释放锁 session2获得锁，得到查询结果 表锁总结： MyISAM在执行查询语句前，会自动给所有涉及到的表加读锁，在执行增删改操作前，会自动给所有涉及到的表加写锁。 MySQL的表级锁有两种模式：表共享读锁和表独占写锁 加读锁不会阻塞其他线程对同一表的读请求，但会阻塞对同一表的写请求，只有当读锁释放后，才会执行其他线程的写操作。 加写锁会阻塞其他线程对同一表的读和写操作，只有当写锁释放后，才会执行其他线程的读写操作。 所以MyISAM适合大量查询的环境，不适合频繁更新，高并发的情况。 3.2、行锁 特点：偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 建表并插入一些数据： 1234567891011create table test_innodb_lock( a int(11) primary key, b varchar(16))engine=innodb;create index idx_b on test_innodb_lock(b);insert into test_innodb_lock values(1,'1000');insert into test_innodb_lock values(2,'2000');insert into test_innodb_lock values(3,'3000');insert into test_innodb_lock values(4,'4000'); 行锁演示： Session1 Session2 为了更好演示，把MySQL自动提交取消 为了更好演示，把MySQL自动提交取消 更新但是未提交 session2被阻塞，只能等待 提交更新 解除阻塞，更新完成 更新a=1 更新a=3，不会阻塞 InnoDB存储引擎会在对某一行数据进行写操作时加锁，如果其他线程也对这一行数据进行写操作，那么就会阻塞等待获得锁。如果两个线程操作的是不同行的数据，那么互不影响。 另外特别要注意的是InnoDB行锁是通过索引上的索引项来实现的，如果没有使用索引或者索引失效，InnoDB将会使用表锁。如下图所示索引失效情况： 间隙锁：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于值在条件范围内但并不存在的记录叫做“间隙”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。 间隙锁有一个致命的弱点，就是当锁定一个范围键值后，即时某些不存在的键值也会被锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据，在某些场景下可能会对性能造成很大的危害。 如上图所示，session1使用的是范围条件，而id为5的记录并不存在，session2插入id为5的记录结果被阻塞了。 优化建议： 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。 尽量控制事务大小，减少锁定资源量和时间长度 尽可能低级别事务隔离 行锁总结： InnoDB行锁虽然在锁定机制的实现方面比表锁损耗要高，但是在并发能力上看，行锁比表锁要优秀得多，所以在系统并发量较高的时候，InnoDB的整体性能要优于MyISAM。但是行锁也有脆弱的一面，当我们使用不当到底时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM要好，反而更差。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL高级（四）：索引优化]]></title>
    <url>%2F2018%2F06%2F25%2FMySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、准备 上一篇的内容学习了如何使用explain来分析SQL的性能问题，通过这个性能分析利器我们就能够对SQL语句进行索引优化，来帮助我们写出更高性能的SQL语句。好了，接下来开始实战吧。 首先创建一张表： 1234567create table staffs( id int primary key auto_increment, name varchar(24) not null default '' comment '姓名', age int not null default 0 comment '年龄', pos varchar(20) not null default '' comment '职位', add_time timestamp not null default current_timestamp comment '入职时间' ) charset utf8 comment '员工记录表'; 接着添加三列符合索引： 1alter table staffs add index idx_nap(name, age, pos); 2、索引优化全值匹配 type为ref，key为idx_nap，ref为const,const,const表示使用了非唯一性索引，也就是自己创建的idx_nap索引，并且使用了全部索引列。 最左前缀原则（重要） 最左前缀原则指的是复合索引从左边为起点任何连续的索引都能匹配上。从索引的最左边开始，如果中间断了，断了那个索引列的左边部分索引生效，后面的索引列就不生效了。如果不是从最左边开始的，那么索引不会生效。 key为idx_nap表示使用了索引，但是看key_len长度和全值匹配的长度要少，说明该索引只使用了部分索引列，上图语句中由于断了age，所以实际上只用到了name索引列。 type为ALL进行了全表扫描，索引失效，因为违背了最左前缀原则即没有从索引的最左边的索引列开始。 不在索引列上做操作 不要在索引列上做操作，包括计算、函数、自动或者手动类型转换，这样会导致索引失效而转向全表扫描。 例如下图在索引列上使用了函数导致了索引失效： varchar类型的字段千万不能少了引号，会导致隐式类型转换，索引失效。 范围之后全失效 索引列使用范围查找，那么该索引列之后的索引列会失效。 例如下图age使用了范围查找，type为range，key为idx_nap，key_len比全值匹配中的长度要少，说明用到了索引，但是age后面的索引列并没有生效。 使用覆盖索引 我们在写查询语句时，尽量不要使用select *，最好用覆盖索引去查找。 下图第二条语句与第一条语句相比使用了覆盖索引，在Extra字段上显示Using index，性能比第一条要好。 第三条使用了范围查找，根据上面所学type应该是range且索引列用到了name和age，但是这里用到了覆盖索引，type为ref级别，索引列用到了name，虽然索引列只用到了一个，但是type为ref显然比range要好。 第五条语句与第四条语句相比说明select查找的列是索引的全部和部分都能使用覆盖索引。 不要使用不等于 使用!=或者&lt;&gt;会导致索引失效而使用全表扫描，如图所示。 like查询不要以通配符开头 使用like查询时，如果以通配符开头%abc，那么索引也会失效导致全表扫描。 但是如果业务中非得使用通配符开头的话，我们可以使用覆盖索引来解决索引失效问题。 少用or或in 使用or或者in也会导致索引失效。 索引对排序的影响 通过之前的学习，我们了解到索引具有排序功能，如果能够利用索引的排序功能对SQL进行排序，也能提高SQL的查询速度。如果不能利用索引的排序功能，MySQL就得自己实现排序功能来满足用户需求，这时通过explain执行计划会发现Extra那一栏出现Using filesort。所以我们在优化SQL时，应该尽量使用索引排序，避免Using filesort。 order by满足两种情况会使用索引进行排序，第一种order by满足索引最左前缀原则，第二种使用where子句与order by子句组合满足最左前缀原则。 索引对分组的影响 group by的实质是先排序后分组，group by使用索引也是遵循最左前缀原则，还有就是能写在where的限定条件就不要用having去限定了。 3、补充 下面注意这种写法，这种写法虽然看起来比较怪异，但是其实是满足最左前缀原则的， MySQL查询优化器会帮我们优化好顺序。 下图的语句中，like为范围查找，根据范围之后全失效，索引列应该只用到了一个，但是实际上全部都用到了，因为like后跟的是Ju%，通配符前面其实是常量了，后面的索引列可以用上。如果like后跟的是%abc%或者%abc，那么这样是范围了，满足范围以后全失效。 4、建议 对于单值索引，尽量选择针对当前query过滤性更好的索引。 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。 在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引。 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL高级（三）：explain介绍]]></title>
    <url>%2F2018%2F06%2F24%2FMySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Aexplain%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1、explain简介 MySQL提供了一个explain命令，它可以对select语句进行分析，并且输出select执行的详细信息，包括该语句是否使用了索引、是否进行了全表扫描等等，以帮助程序员对SQL语句进行优化。 explain使用方法十分简单，只需要在select语句前加上explain即可。 12345678910111213mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info type: constpossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 Extra: NULL1 row in set, 1 warning (0.00 sec) 2、explain输出属性含义 带*号的表示在性能分析时要着重关注的点 id* select 查询的序列号，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般有三种情况： 第一种：id全部相同，sql的执行顺序是由上至下； 第二种：id全部不同，sql的执行顺序是根据id大的优先执行； 第三种：id既存在相同，又存在不同的。先根据id大的优先执行，再根据相同id从上至下的执行。 select_type select 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询。 simple：简单的select 查询，查询中不包含子查询或者union primary：查询中若包含任何复杂的子查询，最外层查询则被标记为primary subquery：在select或where 列表中包含了子查询 derived：在from列表中包含的子查询被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表里 union：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived union result：从union表获取结果的select table 表示查询涉及的表或衍生表。 type* type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等。 all：全表扫描，性能最差 index：从索引树中查找，比全表扫描要好一点 range：表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。 ref：表示使用非唯一性索引，表中有多条记录匹配 eq_ref：联表查询时使用主键或者唯一索引，表中只有一条记录匹配 const ：单表查询时使用主键或者唯一索引，表中只有一条记录匹配 system：表中只有一条记录，这是const类型的特例。 不同type类型的性能关系如下： all &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system possible_keys 表示在查询时，可能用到的索引，但是不是一定会被用到。 key* 表示在查询时，实际用到的索引。若为null，则表示没有使用索引。 key_len 表示查询优化器使用了索引的字节数，这个字段可以评估复合索引是否全部被使用。 ref 表示哪些列或常量被用于查找索引列上的值。 rows* MySQL查询优化器根据统计信息, 估算SQL要查找到结果集需要扫描读取的数据行数。这个值非常直观显示SQL的效率好坏, 原则上rows越少越好。 extra* explain中的很多额外的信息会在Extra字段显示, 常见的有以下几种内容: Using filesort：表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果，建议优化。 Using temporary：表示使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by，出现这个更要立刻优化sql。 Using index：表示查询语句中使用到了覆盖索引，避免访问了表的数据行，性能不错。（覆盖索引指的是select要查找的数据列是索引的全部或者部分，这样MySQL就可以根据索引返回select列表中的字段，而不用再读取数据文件） Using where：表示使用了where过滤。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL高级（二）：索引介绍]]></title>
    <url>%2F2018%2F06%2F24%2FMySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1、索引概述 MySQL官方对索引的定义是可以帮助MySQL高效获取数据的数据结构。 我们可以形象的将索引比喻成一本书的目录，想象一下在没有目录的情况下，我们要查找一本书的内容时可能就要从头开始查找，当存在目录时，这个目录会将这本书的内容排好序指定页数，我们只要按照目录的指引就能查找到所需要的内容，大大提高了效率。 因此我们可以把索引简单的理解为排好序的快速查找数据结构。 索引既然是一种数据结构，那它是哪一种数据结构呢？索引的数据结构有很多种，比如B-TREE、B+TREE、hash index等。 我们拿常用的二叉树来分析索引的工作原理： 2、索引的优缺点优点 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则真好降低了排序的成本。 缺点 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。 3、索引的分类 单值索引：一个索引只包含单个列，一个表可以有多个单列索引 唯一索引：索引列的值必须唯一，但允许有空值 复合索引：一个索引包含多个列，实际开发中推荐使用 实际开发中推荐使用复合索引，并且单表创建的索引个数建议不要超过五个 ４、索引的使用基本语法创建 12create [unique] index indexName on tableName (columnName...)alter tableName add [unique] index [indexName] on (columnName...) 删除 1drop index [indexName] on tableName 查看 1show index from tableName 索引使用适合建立索引的情况 主键自动建立唯一索引 频繁作为查询条件的字段 查询中与其他表关联的字段，外键字段 经常需要排序、分组和统计的字段 不适合建立索引的情况 表记录很少的情况 经常增删改的表 频繁更新的字段 数据重复且分布平均的字段，比如性别不是男就是女的情况]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL高级（一）：存储引擎]]></title>
    <url>%2F2018%2F06%2F24%2FMySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[1、MySQL各大存储引擎 ＭySQL存储引擎主要有：MyISAM，InnoDB，Memory，Blackhole，CSV，Performance_Schema等，其中最常用的为InnoDB（MySQL5.5以后默认的存储引擎）和MyISAM，本文也主要介绍InnoDB和MyISAM这两种引擎。 2、InnoDB与MyISAM的区别 InnoDB支持事务，MyISAM不支持事务 MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用 InnoDB支持外键，MyISAM不支持 InnoDB是行锁，适合高并发操作，MyISAM是表锁，不适合高并发操作 InnoDB缓存索引和真实数据，MyISAM只缓存索引 3、InnoDB与MyISAM的适用场景 InnoDB由于具有事务处理和外键支持，适合高并发的操作，比较适合于大量insert和update的表。 MyISAM由于不考虑事务和外键，操作时会锁住整张表，所以不适合大量update，但是select的速度会非常快，所以适合有大量select的表。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2018%2F06%2F23%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、什么是类加载机制​ 虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 2、类加载的过程类的生命周期： ​ 类从被加载到虚拟机内存中开始到卸载为止，它整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 加载​ 在加载时虚拟机要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 加载源： 文件，class文件、jar、war等。 从网络中获取。 运行时计算生成，例如动态代理技术。 由其他文件生成，例如jsp文件生成对应Class类。 数据库中读取 验证​ 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 ​ 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备​ 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配 。 ​ 基本数据类型例如int为0，boolean为false，long为0L等，引用类型为null。 ​ 如果类变量同时被static和final修饰，那么在准备阶段就会被初始化为指定的值。 解析​ 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，例如将全类名替换为堆内存中的对象地址。 初始化​ 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。 ​ 初始化步骤： 假如这个类还没有被加载和连接，则程序先加载并连接该类。 假如该类的直接父类还没有被初始化，则先初始化其直接父类 。 假如类中有初始化语句，则系统依次执行这些初始化语句。 ​ 初始化时机： 使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰的除外）和调用类的静态方法时。 使用反射对类进行操作。 当初始化一个类的时候，如果该类的父类还没初始化，则先初始化父类。 先初始化main()方法所在的类。 ​ 不会触发初始化： 通过子类引用父类的静态属性，不会导致子类初始化。 通过数组定义来引用类，不会触发此类的初始化。 调用类的静态常量不会触发此类的初始化。 结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3、类加载器]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
